## Spatial Data with Geopandas

This section is by Alejandro Haerter, a junior majoring in Statistical Data Science and Economics.

### Spatial Data and Python

Spatial data is any information which describes the geographic location and shape of features. We might represent these as:

- Points (address, cities)
- Lines (Roads, rivers)
- Polygons (Property parcels, city boundaries, ZIP codes)

Spatial data is everywhere; we see it on maps, it has legal implications; and it
often delineates demographic information. In short, a data scientist is certain to
encounter spatial data in their career, and should know the tools to work with it.

Traditional Geographic Information Systems (GIS) tools (e.g., ArcGIS, QGIS)
are proprietary, require steep learning curves, and do not implement well with the
data science workflow. Luckily, with **GeoPandas**, we can use Python for spatial data analysis, preserving the data science workflow.

### Introduction to GeoPandas

**GeoPandas** is an open source package which adds support for geographic data
to **pandas** objects, first released in 2014. GeoPandas' two main data structuers
are the `geopandas.GeoSeries`, an extension of the `pandas.Series`, and the
`geopandas.GeoDataFrame`, an extension of the `pandas.DataFrame`.

GeoPandas is capable of geometric operations, transformations, and plotting, all relevant
tools for 

#### GeoSeries

`geopandas.GeoSeries` a subclass of `pandas.Series` which can only store
geometries. Potential geometries include Points, Lines, Polygons, etc. Not all geometries
need be the same type, but must be some form of **Shapely** geometric object.

The `GeoSeries.crs` attribute stores the coordinate reference system (CRS) information
of the `GeoSeries`. A CRS relates how map coordinates relate to real locations on
Earth by specifying a datum (a model of the Earth's shape), a coordinate system (e.g.,
Latitude/Longitude, UTM) and units of measurement (e.g., degrees, meters).

#### GeoDataFrame
A `GeoDataFrame` is the core data stucture of GeoPandas. It can store one or more
geometry columns and perform spatial operations. Essentially, it is a `pandas.DataFrame`  combined with one or more `GeoSeries`.

A mock `GeoDataFrame` might look like:

```
    city       population                   geometry
0  NYC        8800000      POINT (-74.0060 40.7128)
1  Boston      675000      POINT (-71.0589 42.3601)
2  Chicago    2700000      POINT (-87.6298 41.8781)
```

Importantly, while we can have multiple `GeoSeries` in a `GeoDataFrame`, only
one `GeoSeries` at a time is the **active geometry column**. All geometric
operations act on this column; it's accessed by `GeoDataFrame.geometry` attribute.

### Basic Operations

A file containg both data and geometry can be read by `geopandas.read.file()`.
For this example, I use a dataset which contains geometric information for each
of NYC's five boroughs.

```{python}
import geopandas as gpd
from geodatasets import get_path

path_to_data = get_path("nybb")  # map of NYC boroughs
gdf = gpd.read_file(path_to_data)

gdf
```

#### Inspecting a `GeoDataFrame`

GeoPandas syntax is just like pandas. Methods like
`.head()`, `.info()`, and `.shape`, `.rename`, `.drop`, etc., apply, all
work the same. For example, I rename the column `geometry` to `poly`, so that
I don't confuse it with the `.geometry` attribute. (This is an example of good
naming practice to avoid conflicts with built-in attributes or methods.)

```{python}
gdf = gdf.rename(columns={"geometry": "poly"})
gdf.head(1)
```

GeoPandas also has its own functions, methods, and attributes which are specific to it.
Recall `.geometry`, which gives us the **active geometry column**. This `GeoDataFrame`
is still pointing to a column called `"geometry"`, even though its renamed and doesn't
exist. `.set_geometry` fixes this.

```{python}
gdf = gdf.set_geometry('poly')
print(gdf.geometry)
```

Recall how to access CRS:
```{python}
print(gdf.crs)
```

ESPG:2263 is a CRS specific for New York City. It uses feet for distance operations.

#### Area

If I wanted to find the area enclosed by the polygons,
I'd use the `.area` attribute, which gives the area enclosed by each polygon.

```{python}
gdf = gdf.set_index("BoroName") # for legibility
gdf["area"] = gdf.area
gdf["area"]
```

Because of ESPG:2263, area is given in square footage. For example,
Manhattan is `6.364712e+08` = 636,471,200 ft^2^ = 22.9mi^2^.

#### Boundaries and Centroids

Right now, the **active geometry column** contains polygons. We can access the perimeters and the centroids of these polygons:

```{python}
gdf["boundary"] = gdf.boundary
gdf["centroid_ft"] = gdf.centroid

gdf[['boundary','centroid_ft']].head()
```

`gdf` now has boundary and centroid columns as additional
geometry columns, but the active column wont change unless specified.

#### Distance Operation

If I wanted to find the distance between the center of Brooklyn and the center of the
Bronx, that's taking the `distance()` between two centroids.

```{python}
# active geometry set to centroid info
gdf = gdf.set_geometry('centroid_ft')

#finds distance between indeces given
gdf.geometry['Bronx'].distance(gdf.geometry['Brooklyn'])
```

Recall the current EPSG:2263, which is a projection in feet. ~79,000ft $\approx$ ~15mi.

We have all the pandas functionality available here too, for example, `.mean()`:

```{python}
from shapely.geometry import Point

cx = gdf["centroid_ft"].x.mean()
cy = gdf["centroid_ft"].y.mean()
geo_center_ft = Point(cx, cy) # Shapely

print(geo_center_ft)
```


Gives us a Point position of the centroid of centroids, i.e., the 
geographic center of NYC. *Although, that doesn't tell us very much...*

#### Changing CRS

Rule of thumb: Operations which rely on distance and area should use a Projected CRS (m, ft, km, etc). Geographic CRS (degrees) is better for position information, like Lat/Lon of a location. We use `.to_crs()`.

```{python}
# new GeoSeries is just a different projection of existing GeoSeries
gdf['centroid_ll'] = gdf['centroid_ft'].to_crs(4326)
gdf['centroid_ll']
```

centroid_ll is centroid reprojected EPSG:4326, now giving coordinates. E.g., the center of the Bronx is at coordinates
40.85&deg;N, 73.87&deg;W.

```{python}
clon = gdf["centroid_ll"].x.mean()
clat = gdf["centroid_ll"].y.mean()
geo_center_ll = Point(clon, clat) # Shapely

print(geo_center_ll)
```

#### File Writing

When I want to save my `GeoDataFrame` to the computer, we use
`GeoDataFrame.to_file`. GeoPandas will infer by the file format by the
file extension.

```{python}
#| eval: false
# This won't run because geoJSON doesn't support multiple GeoSeries!
gdf.to_file("nyc_boroughs.geojson")
```

I recommend using feather.

```{python}
#| eval: false
# Use Feather!
import pyarrow
gdf.to_feather("nyc_boroughs.feather")
```

Just as pandas can handle file types `.csv`, `.feather`, `.html`, etc., GeoPandas data can
also be stored in multipe file types, like `.shp`, `.geojson`, and also `.feather`! 
These file types are are used by a variety of different GIS software, but they all 
contain information which can read as a `GeoDataFrame`.


#### Other Useful Methods

- `length()`
  Returns length of geometries (useful for LineStrings like roads).  

- `intersects(other)`  
  True if two geometries overlap or touch.  

- `contains(other)`
  True if one geometry fully contains another.  

- `buffer(distance)`  
  Creates a new geometry expanded outward (or inward if negative) by the given distance.  

- `equals(other)` 
  Checks geometric equality

- `is_valid`
  Boolean check: are geometries valid (no self-intersections, etc.)?  


### Plotting

GeoPandas is capable of plotting/mapping spatial data on both static
and interactive figures, using **Matplotlib** and **Folium** respectively.

#### Static Maps

Plotting operations are done on the active geometry column with
Matplotlib syntax, `.plot()`.

This code plots the polygons and colors them by their total area:
```{python}
# active geometry column = poly
gdf = gdf.set_geometry("poly")
gdf.plot('area', legend=True)
```

We can map multiple `GeoSeries` by using one plot as an axis for another.
First, we need to verify that 
`centroid_ll` and `poly` are in the same CRS by setting both to ESPG:4326, which gives Latitude and Longitude.
I can use the `.crs` attribute from one `GeoDataFrame` as input for `.to_crs` to ensure a match. This code corrects the CRS and plots both centroids and polygons:
```{python}
ax = gdf.set_geometry("poly").to_crs(gdf["centroid_ll"].crs).plot()   # polygons in lat/lon
gdf.set_geometry("centroid_ll").plot(ax=ax, color="red")
```

### Interactive Maps

Geopandas uses a Folium/Leaflet backend to make interactive maps very easy, using
`.explore()`.

This code gives an interactive map of the same data:

```{python}
gdf = gdf.set_geometry("poly")
gdf.explore("area", legend=False, zoom_to_layer=True)
```

### Worked Out Example: NYC Collision Data

This section demonstrates the start-to-finish workflow of using GeoPandas on a real-world
dataset. We will be using the cleaned NYC collision data, courtesy of Wilson Tang. 
Additionally, for our spatial data, I'll be using the `.shp` file from the NYC Modified Zip Code Tabulation Areas (MODZCTA) dataset. ZIP codes can be reassigned and their boundaries changed;the goal of this dataset is to preserve the ZIP code shapes for
geospatial analysis.

**Goal: overlay crash locations on a map of NYC**.

#### Load and Inspect Data

We begin by installing our required dependencies, and loading our datasets.

```{python}
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

crash_df = pd.read_feather('data/nyc_crashes_cleaned.feather')

zip_gdf = gpd.read_file("data/MODZCTA/geo_export_e47f7c47-73ce-47ac-b45f-2f0d7d74a8d2.shp")

zip_gdf.head()
```

`crash_df` is our `pandas.DataFrame` which collision data, and `zip_gdf` is our
`GeoPandas.GeoDataFrame` which contains 

```{python}
crash_df = crash_df.dropna(subset=["longitude", "latitude"])
zip_gdf = zip_gdf.drop(columns=["label", "zcta"])
```

#### Data Overlay

`crash_df` doesn't yet have an active geometry column to use for plotting, but does have
Latitude and Longitude information. Function `gpd.points_from(x, y)` can take
these inputs (which use ESPG:4326) to produce a `GeoSeries` of geometric 
`shapely.Point` objects. The new `crash_gdf` `GeoDataFrame` combines these two.


```{python}
# Create gdf so we can visualize
crash_gdf = gpd.GeoDataFrame(
    crash_df,
    geometry=gpd.points_from_xy(crash_df["longitude"], 
                                crash_df["latitude"]),
    crs="EPSG:4326"
)

# Double-check: ensure geodataframes same CRS
zip_gdf = zip_gdf.to_crs(crash_gdf.crs)
```

Using Matplotlib syntax, I use add `zip_gdf` to the `.plot()`, specifying how
I want them to appear. I do the same for `crash_gdf`.

```{python}
# Overlay crashes on Borough Polygons
fig, ax = plt.subplots(figsize=(7, 7))
zip_gdf.plot(ax=ax, facecolor="none", edgecolor="black", linewidth=0.8)
crash_gdf.plot(ax=ax, markersize=1, color="red", alpha=0.5)
ax.set_title("NYC Crashes, Labor Day Week 2025")
plt.show()
```

This overlay uses two `GeoSeries`, each from a different `GeoDataFrame`. In this case, it was necessary to keep the two seperate, as they have fundamentally different structures.

#### Spatial Joins

There are advantages of using just one `GeoDataFrame`. We use spatial join function
`gpd.sjoin()`, which parallels `pd.merge`. This function combines two dataframes
by matching keys and a join condition type.

```{python}
# Crashes put within zips
# predicate="within" requires all of a geometry's points to be within
# the interior of the spatially joined geometry (and none on the exterior)
joined = gpd.sjoin(crash_gdf, zip_gdf, predicate="within", how="left")

# count number of crashes per ZIP; creates new Series
# "modzcta" same as zip code. it says to group by zip code.
counts = joined.groupby("modzcta").size().rename("n_crashes")

# Attach crash counts back to the polygon GeoDataFrame
zip_counts = zip_gdf.merge(counts, on="modzcta", how="left").fillna({"n_crashes": 0})
zip_counts = zip_counts.set_geometry("geometry").to_crs(4326)

zip_counts[["modzcta", "n_crashes"]].head()
```

The new `GeoDataFrame` `zip_counts` gives us crash count by ZIP code, which allows
us new plotting opportunities.

#### Plotting Joined Data

Choropleth maps provide an easy way to visualize how a variable varies across a geographic
area or show the level of variability within a region.

```{python}
# Plot polygons colored by crash counts
fig, ax = plt.subplots(figsize=(7, 7))
zip_counts.plot(ax=ax, column="n_crashes", legend=True)
ax.set_title("Crashes per NYC ZIP")
plt.show()
```

Interactive choropleth maps are especially helpful on websites. `tooltip`
specifies which two variables appear when I hover the mouse over a given polygon.

```{python}
# render and auto-fit to layer
zip_counts.explore(column="n_crashes",
                   legend=True,
                   tooltip=["modzcta","n_crashes"],
                   zoom_to_layer=True)
```

### Further Readings

- [GeoPandas](https://geopandas.org/en/stable/index.html):
    See more examples of GeoPandas uses.
- [Pandas](https://pandas.pydata.org/docs/): 
    Not technically a dependency, but complete understanding of Pandas syntax
    is necessary to be successful with GeoPandas. See Pandas section in the classnotes.
- [Shapely](https://shapely.readthedocs.io/en/stable/): 
    GeoPandas leverages Shapely for geometric object types and operations.
    You won't interface much with Shapely directly, but is helpful to have a basic understanding of.
- [Matplotlib](https://matplotlib.org/stable/index.html): 
    Static plotting operations use Matplotlib syntax. 
- [Folium](https://python-visualization.github.io/folium/latest/): 
    Interactive mapping uses a Folium backend. Folium is a very powerful tool
    for spatial visualization, which warrants its own topic presentation.
- [EPSG](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset):
    Familiarize yourself with the most common CRS, which are given by unique EPSG codes.
    The EPSG database currently contrains over 5000 unique entries.