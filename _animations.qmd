---
title: Animations
jupyter: python3
---


This section was created by Justin Tran, an Undergraduate 
Junior majoring in Applied Data Analysis with minors in 
Public Policy and Urban and Community Studies.

For this section, we will demonstrate Matplotlib's `FuncAnimation` tool, a powerful way to turn static plots into grand visualizations.


### What is Data Animation?

Data Animation is the process of showing change over time through a continously updating plot.

It is commonly used to visualize progress, simulations, or changing datasets, including:

- Simulations like rolling dice.
- A scatterplot which updates with new data.
- A line chart that grows over time, like exponential graphs.

[![Mathematica's Animated Bar Chart Race](https://i.sstatic.net/vrU3R.gif)](https://mathematica.stackexchange.com/questions/257802/animated-bar-chart-race-a-popular-data-visualization/)


### Static vs Animated Plots

#### Static Plots
- Pros
  - Quick to interpret as all the data is shown at once.
  - Low computational cost as it's fast to render.
  - Reproducible as it's the same image each time.
- Cons
  - Hard to illustrate motion or trends.
  - Overcrowding data can make it hard to understand.
  - Less engaging over animated plots.
 
#### Animated Plots
- Pros
  - Shows progressions over time, ideal for simulations.
  - Can show patterns and change in dynamics.
  - More engaging and interactive.
- Cons
  - Harder to render as it uses more code and storage.
  - Can be hard to see if motion is too fast.
  - Can distract audiences if overused.

### Matplotlib

Created in 2008 by John D. Hunter, Matplotlib is one of Python's most used library for plotting and visualization. You are able to create line, scatter, bar, and histogram plots. You can customize colors, labels, and configure layouts. For this section, we can use Matplotlib's advanced modules like animations to make more dynamic visualizations.

The specific tool we are focused on is `matplotlib.animation.FuncAnimation`, it is used to update our plot frame-by-frame.


#### Installation of Matplotlib and FuncAnimation

To use `FuncAnimation`, you first will need to install `Matplotlib`. Inside your terminal, use the corresponding manager you currently use.

```
pip install matplotlib                     # Users with pip
conda install -c conda-forge matplotlib    # Users with conda
pixi add matplotlib                        # Users with pixi
uv add matplotlib                          # Users with uv
```

To ensure that you installed matplotlib correctly, run this code to check it's version. If you get a version number, then it is installed.

```
import matplotlib
print(matplotlib.__version__)
```

Once you've installed matplotlib, now it's time to import it. To import, run these codes.

```
import matplotlib.pyplot as plt
```

### Creating Static Plots

Normally, you may want to create a simple plot where you are rolling a dice and see the probability of you rolling a six. So, we will create a line plot.

```
import random
import matplotlib.pyplot as plt

random.seed(3255)

# The Function
def prob_six(trials):
    results = []
    prop_six = []
    for i in range(trials):
        roll = random.randint(1, 6)        # roll a 6-sided die
        results.append(roll == 6)          # Adds a value only if it rolls a 6
        prop_six.append(sum(results) / len(results))
    return prop_six

# Matplotlib's pyplot
plt.figure(figsize=(6, 3))
plt.hlines(1/6, 0, 500, linestyles='dashed', color='gray')  
plt.plot(prob_six(500), color='tab:green')
plt.ylim(0, 1)
plt.title("Rolling a Die — Probability of Getting a 6")
plt.ylabel("Proportion of 6s")
plt.xlabel("Number of Rolls")
plt.show()
```

You can also use different types of charts, like bar charts. This example will show how many times each number gets rolled when we roll a dice hundreds of times.

```
import random
import matplotlib.pyplot as plt

random.seed(3255)

# The Function
trials = 1000
rolls = [random.randint(1, 6) for _ in range(trials)]

counts = [rolls.count(i) for i in range(1, 7)]

# Matplotlib's pyplot
plt.figure(figsize=(6, 4))
plt.bar(range(1, 7), counts, color='gold', edgecolor='black')
plt.title("Rolling a Die — Frequency of Each Face")
plt.xlabel("Die Face")
plt.ylabel("Frequency")
plt.xticks(range(1, 7))
plt.show()
```

### FuncAnimation

Now, to use FuncAnimation, we need to understand how to call it and all the required arguments within.

```
from matplotlib.animation import FuncAnimation

anim = FuncAnimation(
    fig,
    update,
    frames,
    interval,
    repeat
)
```

- `fig` = The Matplotlib figure that will be animated
- `update` = The update function that's called once per frame
- `frames` = The total number of frames
    - Will be `range(n)`, where n is the total number of frames
- `interval` = The delay between frames in milliseconds
    - interval=`50` means 20 frames per second
- `repeat` = Whether you would like to loop the animation
    - Either `False` or `True`

Now, to do the animation on the probability of rolling a 6, this is the code to run.

```
from matplotlib.animation import FuncAnimation

prop_six = prob_six(500)
frames = range(len(prop_six))

# This starts to create the figure
fig, ax = plt.subplots(figsize=(8, 4))

# This is the update function
def update(frame):
    ax.clear()
    ax.set_title("Rolling a Die — Probability of Getting a 6")
    ax.set_ylabel("Proportion of 6s")
    ax.set_xlabel("Number of Rolls")
    ax.hlines(1/6, 0, frame+1, linestyles='dashed', color='gray')
    ax.set_ylim(0, 1)

    # This shows the percentage at each frame
    ax.text(
        frame+1,
        prop_six[frame] * 1.05,
        f'{prop_six[frame]:.3f}',
        weight='bold',
        color='tab:green'
    )
    ax.plot(range(1, frame+1), prop_six[:frame], color='tab:green')

# Now we create the animation
anim = FuncAnimation(fig, update, frames=frames, repeat=False, interval=50)

# This saves as a gif
anim.save("dice_prob.gif", writer="pillow", fps=20)

plt.close(fig)
```

[![Animated Dice Roll, Probabiliity of rolling a 6](dice_prob.gif)]

```
from matplotlib.animation import FuncAnimation

num_faces = 6
trials = 1000

rolls = []

# Creating the figure
fig, ax = plt.subplots(figsize=(6, 4))

# The update function
def update(frame):
    ax.clear()
    rolls.append(random.randint(1, num_faces))
    counts = [rolls.count(i) for i in range(1, num_faces + 1)]
    
    # Bar chart
    ax.bar(range(1, num_faces + 1), counts, color="gold", edgecolor="black")
    ax.set_title("Rolling a Die — Frequency of Each Face")
    ax.set_xlabel("Die Face")
    ax.set_ylabel("Frequency")
    ax.set_xticks(range(1, num_faces + 1))
    ax.set_ylim(0, 300)
    
    # Adds counts above each bar
    for i, count in enumerate(counts, start=1):
        ax.text(i, count + 5, str(count), ha='center', weight='bold', color='navy')

# Creating the animation
anim = FuncAnimation(fig, update, frames=range(trials), repeat=False, interval=20)

anim.save("dice_bar.gif", writer="pillow", fps=30)

plt.close(fig)
```

[![Animated Dice Roll, Frequency of each Number](dice_bar.gif)]

### Animating Crash Locations in NYC

Using the crash data from this semester, something you may want to see is the location of every crash on a map. This is something FuncAnimation does extremely well.

For this example, we will be installing `contextily.`

```
pip install contextily                     # Users with pip
conda install -c conda-forge contextily    # Users with conda
pixi add contextily                        # Users with pixi
uv add contextily                          # Users with uv
```

```
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import contextily as cx


df = pd.read_feather("ids-f25/data/nyc_crashes_cleaned.feather")
df["crash_datetime"] = pd.to_datetime(df["crash_datetime"], errors="coerce")
df = df.dropna(subset=["latitude", "longitude", "borough"])

# Creating hourly bins and sorting it chronologically
df["hour_bin"] = df["crash_datetime"].dt.floor("h")
df = df.sort_values("hour_bin")

# We convert it to a GeoDataFrame so we can plot on a map
gdf = gpd.GeoDataFrame(
    df,
    geometry=gpd.points_from_xy(df.longitude, df.latitude),
    crs="EPSG:4326"
).to_crs(epsg=3857)

# For style, we can color code each borough for more contrast
borough_colors = {
    "MANHATTAN": "red",
    "BROOKLYN": "gold",
    "QUEENS": "limegreen",
    "BRONX": "royalblue",
    "STATEN ISLAND": "purple"
}
gdf["color"] = gdf["borough"].str.upper().map(borough_colors).fillna("gray")

# Creating the bounds
xmin, ymin, xmax, ymax = gdf.total_bounds
pad_x = (xmax - xmin) * 0.05
pad_y = (ymax - ymin) * 0.05
xmin, xmax = xmin - pad_x, xmax + pad_x
ymin, ymax = ymin - pad_y, ymax + pad_y

# This creates the figure again
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_title("NYC Motor Vehicle Collisions — Aug 31 to Sep 6, 2025", fontsize=14)
ax.set_axis_off()

cx.add_basemap(ax, crs=gdf.crs, source=cx.providers.CartoDB.Positron, zoom=11)

# Now we build each frame, which we use by per hour
hours = sorted(gdf["hour_bin"].unique())

def update(frame):
    ax.clear()
    ax.set_axis_off()
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    cx.add_basemap(ax, crs=gdf.crs, source=cx.providers.CartoDB.Positron, zoom=11)

    # Making it cumulative so all points are visible
    current_time = hours[frame]
    subset = gdf[gdf["hour_bin"] <= current_time]

    # Plot crash points
    ax.scatter(
        subset.geometry.x,
        subset.geometry.y,
        s=8,
        c=subset["color"],
        alpha=0.6,
        edgecolor="none"
    )

    # Dynamic title per hour
    ax.set_title(f"NYC Motor Vehicle Collisions\nUp to {current_time:%b %d %Y %H:%M}",
                 fontsize=12)

# Creating the Animation
anim = FuncAnimation(fig, update, frames=len(hours), repeat=False, interval=100)

anim.save("nyc_crashes_map.gif", writer="pillow", fps=10)
plt.close(fig)
```

[![NYC Crash Animation](nyc_crashes_map.gif)]

### Crash Causes Pie Chart

Another example that we can use is seeing the proportion of causes of crashes in NYC.

```
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation


df = pd.read_feather("ids-f25/data/nyc_crashes_cleaned.feather")
df["crash_datetime"] = pd.to_datetime(df["crash_datetime"], errors="coerce")

# Creating daily bins
df["date"] = df["crash_datetime"].dt.date

# Wanting the top causes
top_causes = (
    df["contributing_factor_vehicle_1"]
    .value_counts()
    .head(6)
    .index
)

df = df[df["contributing_factor_vehicle_1"].isin(top_causes)]

# Aggregate daily counts
daily_counts = (
    df.groupby(["date", "contributing_factor_vehicle_1"])
    .size()
    .reset_index(name="count")
)

dates = sorted(daily_counts["date"].unique())

# For asesthetic, use different colors
cause_colors = {
    cause: color for cause, color in zip(
        top_causes,
        ["#d62728", "#ff7f0e", "#2ca02c", "#1f77b4", "#9467bd", "#8c564b"]
    )
}


# Setting up the figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.axis("equal")  

# Starting the first frame
current_data = daily_counts[daily_counts["date"] == dates[0]]
sizes = current_data["count"]
labels = current_data["contributing_factor_vehicle_1"]
colors = [cause_colors.get(label, "gray") for label in labels]  
wedges, texts = ax.pie(sizes, labels=labels, colors=colors, startangle=90, labeldistance=1.2)
title = ax.text(0, 1.1, f"Crash Causes — {dates[0]}", ha="center", fontsize=14)
plt.tight_layout(pad=3.0)  

# Creating the update function
def update(frame):
    ax.clear()
    ax.axis("equal")

    current_date = dates[frame]
    current_data = daily_counts[daily_counts["date"] == current_date]

    # To keep the order consistent
    current_data = current_data.set_index("contributing_factor_vehicle_1").reindex(top_causes).fillna(0)

    sizes = current_data["count"]
    labels = current_data.index
    colors = [cause_colors.get(label, "gray") for label in labels]

    ax.pie(
        sizes,
        labels=labels,
        colors=colors,
        startangle=90,
        autopct="%1.1f%%",
        labeldistance=1.2
    )
    ax.set_title(f"NYC Crash Causes — {current_date}", fontsize=14)
    plt.tight_layout(pad=3.0)


anim = FuncAnimation(fig, update, frames=len(dates), repeat=False, interval=1000)
anim.save("nyc_crash_causes_pie.gif", writer="pillow", fps=1)

plt.close(fig)
```

[![NYC Crash Cause](nyc_crash_causes_pie.gif)]

### Saving Animations

To save the animations as a GIF, we need to use pillow to write it. First, we need to install it.

```
pip install pillow                         # Users with pip
conda install -c conda-forge pillow        # Users with conda
pixi add pillow                            # Users with pixi
uv add pillow                              # Users with uv
```

Then, run the command:

```
anim.save('name.gif', writer='Pillow', fps=10) # fps can change to whatever you like
```

### Conclusion

Data animation helps transform static figures into dynamic pieces. By using tools like Matplotlib's `FuncAnimation`, we can reveal the change in data over time.

Whether it's a simulation or real maps of crashes in NYC, animation helps highlights patterns and behaviors that normally isn't seen in static charts.

Ultiamtely, it makes complex information easier to interpet and more engaging to share.

### References

To learn more about Matplotlib, FuncAnimation, or other articles, please feel free to read them here.

[Matplotlib](https://matplotlib.org/stable/index.html)

[Matplotlib Quick Start Guide](https://matplotlib.org/stable/users/explain/quick_start.html)

[Matplotlib FuncAnimation](https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html)

[TowardsDataScience Tutorials](https://towardsdatascience.com/animations-with-matplotlib-d96375c5442c)


