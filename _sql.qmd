## Database operation with Structured query language (SQL)

This section was prepared by Lewis Milun.

### Introduction
Structured Query Language (SQL) is one of the standard languages that is used 
to work with large databases. It uses tables to store and display data, 
creating an organized and comprehendable interface that makes it far easier to track and view your data.

Some advantages of using SQL include its ability to handle large amounts of data
while simultaneously simplifying the process of screating, updating, and 
retrieving any data you may want.

The biggest advantage of using SQL for the purposes of this class, is that it
can very easily connect with python and R. This makes it so that we can have
all of the benefits of working with SQL while still working in the python
environment we already have set up.

### Setting up Databases
In this section, we will be working with two databases, one that's built into
a python package (nycflights13) and one that we used for our midterm project 
(311 Service Requests)

#### nycflights13
This database is built into the pandas package and includes flight data for all
flights that left New York City airports in 2013. The database includes several
tables including ones that detail each flight, airline, airport, and much more
info regarding the flights. The data in this database is contained across 
several tables. Data stored like this would typically be irritating to deal with
however it is proven simple when working with SQL.

To set up this database, we need to import the proper packages:
```{python}
import sqlite3
import pandas as pd
from nycflights13 import flights, airlines, airports
```

Here we imported "sqlite3" which is the package to import when working with SQL.
We also imported "pandas" which also includes the nycflights13 database and from
there imported the three tables we will be working with.

Now, we want to establish the connection between python and our sql database:
```{python}
nycconn = sqlite3.connect("nycflights13.db")
```

This snippet both creates the nycflights13.db database and establishes nycconn as
our connection to this database.

Next step is to add the three tables we imported from nycflights13 to the 
database:
```{python}
flights.to_sql("flights", nycconn, if_exists="replace", index=False)
airlines.to_sql("airlines", nycconn, if_exists="replace", index=False)
airports.to_sql("airports", nycconn, if_exists="replace", index=False)
```

What this does is converts the three pandas dataframes into tables in the sql
database. The if_exists argument handles what would happen if there is already
a table in the database with the same name. The index argument is determining whether or not the first column of the dataframe should be handled as the 
index of the table in the dataframe.

#### serviceRequests Database
First, we need to import our serviceRequests data from the csv in the data
folder:
```{python}
df = pd.read_csv("data/serviceRequests06-09-2025_07-05-2025.csv")
```

Now we need to repeat the process from nycflights13 but for our serviceRequests:
```{python}
srconn = sqlite3.connect("serviceRequests.db")

df.to_sql("requests", srconn, if_exists="replace", index=False)
```

Here we imported the dataframe we got from the csv file as the only table in the
serviceRequests.db database.

### Query Basics
Now we can move onto working with the data in our SQL databases. The most common
use for SQL is writing a "query" which is a statement sent to the SQL databse
that returns a selection of rows and columns from the tables in a database.

We will be looking at the "flights" table in our nycflights13 database for this
seciton.

#### SELECT and FROM
The following is the most basic possible query one can perform:
```{python}
query = """
SELECT *
FROM flights;
"""
pd.read_sql_query(query, nycconn).head()
```

This snippet represents the basic form of writing SQL queries in python. We
create a variable 'query' that contains the statement we intend to pass into 
SQL. The last line then uses the nycconn connection we created earlier to pass
our query into SQL and it returns the head() of the result we get back.

This query is the most basic query, as it returns the entire flights table. The
SELECT line of the query is where you put the names of which columns you want 
from your table. You specify which table you want to work with on the FROM line.
We put "*" in our SELECT line which returns all columns.
All SQL queries must end with ";", otherwise you'll get an error.

Now let's try to simplify what we're seeing by only looking at the origins and
destinations of the flights:
```{python}
query = """
SELECT origin, dest
FROM flights;
"""
pd.read_sql_query(query, nycconn).head()
```

Here we replaced the "*" in our SELECT statement with "origin, dest"
This told SQL to only return those two columns from the database.

#### ORDER BY
These columns are quite messy to look at so let's try sorting them by origin:
```{python}
query = """
SELECT origin, dest
FROM flights
ORDER BY origin;
"""
pd.read_sql_query(query, nycconn).head()
```

Here we added a new "SORTBY" line. This line tells SQL what columns to sort 
the list by.

You can sort by multiple columns just by listing them with commas in between:
```{python}
query = """
SELECT origin, dest
FROM flights
ORDER BY origin, dest;
"""
pd.read_sql_query(query, nycconn).head()
```

#### SELECT DISTINCT
Now that the list is properly sorted, we can see that there are multiple flights
from each origin to destination combination. If we want to only see the unique
columns, we can do this:
```{python}
query = """
SELECT DISTINCT origin, dest
FROM flights
ORDER BY origin, dest;
"""
pd.read_sql_query(query, nycconn).head()
```

Here we replaced out "SELECT" statement with a "SELECT DISTINCT" statement. This
tells SQL to only return the unique columns from the query.

### Conditionals

Put matreials on topic 3 here.


### Joins

Put sumaries here.

### Creating Tables

Put links to further materials.

### Statement Order


### Conclusion


### Further Readings